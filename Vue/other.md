# 其他
### 1、当我们点击按钮的时候动态给 data 增加的成员是否是响应式数据，如果不是的话，如果把新增成员设置成响应式数据，它的内部原理是什么。
```
let vm = new Vue({
 el: '#el'
 data: {
  o: 'object',
  dog: {}
 },
 method: {
  clickHandler () {
   // 该 name 属性是否是响应式的
   this.dog.name = 'Trump'
  }
 }
})
```
答： 动态添加的属性不是响应式数据。把新成员设置为响应式数据，需要使用 `$set` 方法。通过 `Object.defineProperty` 方法重新定义对象属性，配置属性的 set、get，从而实现新增属性的响应式。
> 同样的对于响应式的数组，增加元素、修改数组长度时，数组的这些变化也不会反映到页面中

### 2、简述 Diff 算法的执行过程
答：  
  + 首先 `diff` 算法的关键就是节点复用，作用是为了减少更新量，找到最小差异部分的 `DOM` ，只更新差异部分的 `DOM` 。其次 `diff` 算法只做同层级比较，也就是说新旧节点如果相同，但是不在同一级别，也会重新创建该节点，而不是复用。 `diff` 的过程就是调用名为 `patch` 的函数，比较新旧节点，一边比较一边给真实的DOM打补丁
  + 执行过程
    - 当数据变化的时候，`set` 方法会调用 `Dep.notify` 通知所有订阅者。
    - 订阅者会执行 `patch` 方法，对比新旧 2 个 `dom` 节点。
    - `diff` 算法开始。
      + 判断新旧 `dom` 节点是否为同一节点。
      + 不是同一节点。
        - 增加新节点到 `dom` 中（立即）。
        - 返回新节点的 `vNode` 对象。
      + 是同一节点。
        - 调用 `patchVnode` 函数。
          + 对比新旧 2 个节点是否为同一个对象的引用。如果是，直接返回，不做任何操作。
          + 如果新节点的 `data` 属性不为空。
            - 遍历执行 `cbs` 对象中所有 `update` 方法。
            - 执行新节点中的 `update` 方法。
          + 对比新旧 2 个节点，如果都是文本节点，且2个节点文本不相等。
            - 如果老节点有子节点，则删除该子节点。
            - 把新节点的 `text` 的值，赋值到旧属性响应位置。
          + 如果不为文本节点，或新旧 2 个节点不相等。
            - 如果老节点没有子节点，而新节点有子节点。
              + 如果老节点存在 `text` 属性， 将老节点的 `text` 属性清空。
              + 调用 `addVnodes` 方法，将新节点子节点实例化，添加到 `dom` 中。
            - 如果老的节点有子节点，而新的节点没有子节点，调 `removeVnodes` 方法，删除老节点的对应子节点。
            - 如果新老节点都有子节点。且不为用一个引用对象。则执行 `updateChildren` 方法比较子节点。
              + 循环遍历，直至老的开始节点小于等于老的结束节点，且新的开始节点小于等于新的结束节点。
                > 此处对比新老节点是否相等，调用的 `sameVnode` 函数，对比新老节点的 `key` 和 `sel` 是否都相等。sel 为虚拟节点的选择器标识，例： `div#app` 。 
                - 验证老开始、新开始、老结束、新结束节点是否存在，如果不存在分别取下一个或上一个节点。
                - 对比老开始节点和新开始节点是否相等，如果相等。
                  + 调用 `patchVnode` 函数，判断上述 2 个节点是否还有子节点，递归调用。
                  + 将老、新子节点下标各自向右移动一位，获取各自数组中的下一个值。
                - 对比老结束节点和新结束节点是否相等，如果相等。
                  + 调用 `patchVnode` 函数，判断上述 2 个节点是否还有子节点，递归调用。
                  + 将老、新子节点下标各自向左移动一位，获取各自数组中的上一个值。
                - 对比老开始节点和新结束节点是否相等，如果相等。
                  + 调用 `patchVnode` 函数，判断上述 2 个节点是否还有子节点，递归调用。
                  + 将老节点真实开始 `dom` 元素，插入到老的结束节点之后位置。
                  + 老开始节点下标右移，新的结束节点下标左移，分别获取下一个和上一个节点。
                - 对比老结束节点和新开始节点是否相等，如果相等。
                  + 调用 `patchVnode` 函数，判断上述 2 个节点是否还有子节点，递归调用。
                  + 将老节点真实结束 `dom` 元素，插入到老的开始节点位置。
                  + 老结束节点下标左移，新的开始节点下标右移，分别获上一个和下一个节点。
                - 如果不是以上四种情况。
                  + 遍历新节点，使用新的开始节点的 key 在老节点数组中找相同节点
                    - 如果不存在，说明此节点是新节点
                      + 创建新节点对应的 DOM 元素，插入到 DOM 树
                    - 如果存在
                      + 判断新节点和找到的老节点的 sel 选择器是否相同
                        - 如果不同，说明节点被修改了，重新创建对应的 DOM 元素，插入到 DOM 树中。
                        - 如果相同，
                          + 调用 `patchVnode` 函数，判断上述 2 个节点是否还有子节点，递归调用。
                          + 把找到老节点对应的 DOM 元素，移动到老节点开始的位置。
                    - 新开始节点下标右移，获取下一个节点。