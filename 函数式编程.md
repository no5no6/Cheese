## 函数式编程
一、 名词解释 
+ 纯函数：函数式编程中相同的输入始终或得相同的输出。其优点方便测试、可缓存函数、在多线程环境下不需要访问共享内存数据。
+ 函数式编程： 一种编程思想、范式（类似还有、面向对象、面向过程编程），是对运算过程的抽象，函数式编程中的函数指的是数学中的函数，而不是程序中的函数，函数式编程必定是纯函数。  
+ 柯里化：当一个函数有多个参数的时候，先传递一部分参数调用他（这部分参数为固定值，不会发生变化），然后返回一个新函数，再接收其他剩余可能变化的参数，最后返回结果。 
+ 函子（Functor）是一个容器，函子本身具有对外接口（map方法）。
  - Pointed 函子，实现了 `of` 方法的函子。
  - MayBe 函子，用于过滤空值，避免后续函数执行报错。
  - Elther 函子，用来处理函数执行中的异常。
  - IO 函子，与其他函子区别于 `of` 方法返回一个函数（区别其他函子返回 `value` 值），用于封装非纯函数，让其在调用时再执行，保证函子之间的纯度。
  - Monand 函子,同时拥有 `join` 和 `of` 两个方法，且遵守一些定律（数学定律）。用于解决函子嵌套调用问题。

二、 练习  
+ [模拟 lodash 函数](pretend_lodash.js)
+ 函数编程  
  - 非纯函数  
  ```javascript
    let standard = 18;

    let getResult = age => {
      return age > standard;
    }

    console.log(getResult(20)); // true
  ```

  - 纯函数  
  ```javascript
    let getResult = (age, standard) => {
      return age > standard;
    }

    console.log(getResult(20, 18)); // true
    console.log(getResult(24, 22)); // true
  ```

  - 函数柯里化  
  ```javascript
    let getResultCurry = (standard) => (age => age > standard);

    let standard18 = getResultCurry(18);
    let standard22 = getResultCurry(22);

    console.log(standard18(20));  // true
    console.log(standard22(25));  // true
  ```

  - 通过 lodash curry 函数柯里化  
  ``` javascript
    const _ = require('lodash');

    let getResult = (a, b, c) => {
      return a + b + c;
    }

    let getCurry = _.curry(getResult);
    console.log(getCurry(1)(2)(3));  // 6
    console.log(getCurry(1, 2)(3));  // 6
    let fuc = getCurry(1, 2);
    console.log(fuc(3)); // 6
  ```

  - 实现 lodash curry 函数
  ```javascript
    let getResult = (a, b, c) => {
      return a + b + c;
    }

    const curry = (fn) => {
      const fuc = (...arg) => {
        if (arg.length < fn.length) {
          return (...arg_2) => {
            return fuc(...arg.concat(arg_2));
          }
        }
        return fn(...arg);
      }
      return fuc;
    }

    const curryGetResult = curry(getResult);
    console.log(curryGetResult(1, 2, 3));
    console.log(curryGetResult(1)(2)(3));
    console.log(curryGetResult(1, 2)(3));
  ```

  - 缓存函数  
  ```javascript
    let getResult = (r) => {
    console.log('--enter--');
    return Math.PI * r * r;
    }

    let memoize = (fn) => {
      let cache = {};
      return (...arg) => {
        let key = JSON.stringify(arg);
        cache[key] = cache[key] || fn.apply(fn, arg);
        return cache[key];
      }
    }

    let getResultMemory = memoize(getResult);
    console.log(getResultMemory(2));
    console.log(getResultMemory(2));
    console.log(getResultMemory(4));

    // --enter--
    // 12.566370614359172
    // 12.566370614359172
    // --enter--
    // 50.26548245743669
  ```

  - 通过 lodash memoize 函数 缓存
  ```javascript
    let getResult = (r) => {
      console.log('--enter--');
      return Math.PI * r * r;
    }

    const _ = require('lodash');
    let getResultMemory = _.memoize(getResult);
    console.log(getResultMemory(2));
    console.log(getResultMemory(2));
    console.log(getResultMemory(4));

    // --enter--
    // 12.566370614359172
    // 12.566370614359172
    // --enter--
    // 50.26548245743669
  ```

  - 通过 lodash flowRight 实现函数的组合
  ```javascript
    const _ = require('lodash');

    const reverse = arr => arr.reverse();
    const first = arr => arr[0];
    const toUpper = s => s.toUpperCase();

    const f = _.flowRight(toUpper, first, reverse);
    console.log(f(['one', 'two', 'three']));
  ```

  - 实现 lodash flowRight 函数
  ```javascript
    const reverse = arr => arr.reverse();
    const first = arr => arr[0];
    const toUpper = s => s.toUpperCase();

    const flowRight = (...arg) => {
      let index = 0;
      let argRight = arg.reverse();

      const fuc = (value) => {
        let result = argRight[index](value);

        if (index === argRight.length - 1) {
          return result;
        } else {
          index++;
          return fuc(result);
        }
      }
      return fuc;
    }

    const f = flowRight(toUpper, first, reverse);
    console.log(f(['one', 'two', 'three']));
  ```

  - 借助 reduce 实现 lodash flowRight 函数
  ```javascript
    const reverse = arr => arr.reverse();
    const first = arr => arr[0];
    const toUpper = s => s.toUpperCase();

    const flowRight = (...arg) => value => arg.reverse().reduce((memo, item) => item(memo), value);

    const f = flowRight(toUpper, first, reverse);
    console.log(f(['one', 'two', 'three']));
  ```

  - 组合函数调试
  ```javascript
    const _ = require('lodash');

    const trace = _.curry((tag, value) => {
      console.log(tag, value);
      return value
    });

    const split = _.curry((rule, str) => _.split(str, rule));
    const join = _.curry((rule, str) => _.join(str, rule));
    const map = _.curry((fn, array) => _.map(array, fn));
    const f = _.flowRight(join('-'), trace('bbb'), map(_.toLower), trace('aaa'), split(' '))
    console.log(f('NEVER SAY DIE'))
  ```

  - lodash fp 函数
  ```javascript
    const fp = require('lodash/fp');
    const f = fp.flowRight(fp.join('-'), fp.map(fp.toLower), fp.split(' '))
    console.log(f('NEVER SAY DIE'));
  ```

