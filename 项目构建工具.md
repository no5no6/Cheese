# 项目自动化构建工具
## 概述  
  + 它将项目中繁琐、重复的任务变为自动执行的任务，让你的工作更专注于项目实现本身。  
  + 它解决的问题例如：编译、合并、压缩、加密、单元测试等一系列与项目实现本身无关的事物。
  + 如果把工具按类型分可以分为以下三类：
    - 基于任务运行的工具：  
      Grunt、Gulp 它们会自动执行指定的任务，就像流水线，把资源放上去然后通过不同插件进行加工，它们包含活跃的区，丰富的插件，能方便的打造各种工作流。
    - 基于模块化打包的工具：  
      Browserify、Webpack、rollup.js，有过 Node.js 开发经历的应该对模块很熟悉，需要引用组件直接一个 require 就 OK，这类工具就是这个模式，还可以实现按需加载、异步加载模块。
    - 整合型工具：  
      Yeoman、FIS、jdf、Athena、cooking、weflow 使用了多种技术栈实现的脚手架工具，好处是即开即用，缺点就是它们约束了技术选型，并且学习成本相对较高。
  + Grunt 
    - Grunt 是老牌的构建工具，特点是配置驱动，你需要做的就是了解各种插件的功能，然后把配置整合到 Gruntfile.js 中。
    - Grunt 缺点也是配置驱动，当任务非常多的情况下，试图用配置完成所有事简直就是个灾难；再就是它的 I/O 操作也是个弊病，它的每一次任务都需要从磁盘中读取文件，处理完后再写入到磁盘，例如：我想对多个 less 进行预编译、压缩操作，那么 Grunt 的操作为以下操作，这样一来当资源文件较多，任务较复杂的时候性能就是个问题了。
      > 读取 less 文件 -> 编译成 css -> 存储到磁盘 -> 读取 css -> 压缩处理 -> 存储到磁盘
  + Gulp
    - Gulp 特点是代码驱动，写任务就和写普通的 Node.js 代码一样
    - 特点为对文件读取是流式操作（Stream），也就是说一次 I/O 可以处理多个任务，还是 less 的例子，Gulp 的流程就为以下操作，Gulp 作为任务类型的工具没有明显的缺点，唯一的问题可能就是完成相同的任务它需要写的代码更多一些
      > 读取 less 文件 -> 编译成 css -> 压缩处理 -> 存储到磁盘
  + Webpack
    - 把一切都视为模块：不管是 CSS、JS、Image 还是 HTML 都可以互相引用，通过定义 entry.js，对所有依赖的文件进行跟踪，将各个模块通过 loader 和 plugins 处理，然后打包在一起。
    - 按需加载：打包过程中 Webpack 通过 Code Splitting 功能将文件分为多个 chunks，还可以将重复的部分单独提取出来作为 commonChunk，从而实现按需加载。
    - 不足点为
      + 上手比较难：官方文档混乱、配置复杂、难以调试（Webpack2 已经好了很多）对于新手而言需要经历踩坑的过程；
      + 对于 Server 端渲染的多页应用有点力不从心：Webpack 的最初设计就是针对 SPA，所以在处理 Server 端渲染的多页应用时，不管你如何 chunk，总不能真正达到按需加载的地步，往往要去考虑如何提取公共文件才能达到最优状态。

## 案例
### Grunt

### Gulp（ 样式文件：scss ；模板文件：swig） 
+ 项目中安装 `gulp` 为开发依赖。
  项目根目录执行 `yarn add gulp --dev` 。

+ 添加 `gulpfile.js` 文件。

+ 在 `gulpfile.js` 文件中编写整个构建流程
  - 引入 `gulp` 中的方法 。
    ```javascript
      // 引入 gulp 模块中的方法
      const { src, dest, parallel, series, watch } = require('gulp'
    ```
    > + src 用于读取文件。  
    > + dest 用于输出文件。  
    > + parallel 用于异步执行任务。  
    > + series 用于同步执行任务。  
    > + watch 监视一个文件路径通配符，在文件发生变化后来决定执行某一个任务。  

  - 安装 `gulp-load-plugins` 插件，获得 `plugins` 对象。  
    + 安装依赖模块  
      `yarn add gulp-load-plugins --dev`

    + 编写核心处理代码
      ```javascript
        const load_plugins = require('gulp-load-plugins')
        const plugins = load_plugins();
      ```
    > 安装此插件后，用到的 `gulp` 模块可以用 `plugins.xxx` 来使用，不需要单独再 `require` 某一个 `gulp-xxx` 模块。  

  - 编译样式文件
    + 安装依赖模块 
      `yarn add gulp-sass --dev`  

    + 编写核心处理代码
      ```javascript
        const style = () => {
          return src('src/assets/styles/*.scss', { base: 'src' })
            .pipe(plugins.sass({ outputStyle: 'expanded' }))
            .pipe(dest('dist'))
        }
      ```
      > 1. `base` 属性，设置转换时候的基准路基。例如下边示例 `{base: 'src'}` 输出到目标路径为 `dist/assets/styles/xx.css`  
      > 2. 被转换目录中存在 `_` 开头的样式名，为主文件中依赖文件，转换器默认会忽略，不转换。  
      > 3. `{outputStyle: 'expanded'}` 控制转换后文件，结尾 `}` 显示在新的一行。  

  - 编译脚本文件
    + 安装依赖模块 
      - yarn add gulp-babel --dev
      - `yarn add @babel/core --dev` 
      - `yarn add @babel/preset-env --dev`
        > + babel 只是一个平台，需要处理的具体事物，需要加载其具体处理插件来完成。  
        > + @babel/preset-env 为转换 `es6` 特性插件  

    + 编写核心处理代码
    ```javascript
      const script = () => {
        return src('src/assets/scripts/*.js', { base: 'src' })
          .pipe(plugins.babel({ presets: ['@babel/preset-env'] }))
          .pipe(dest('dist'))
      }
    ```

  - 编译模板
    + 安装依赖模块  
      `yarn add gulp-swig --dev`

    + 编写核心处理代码
      ```javascript
      // 渲染模板对象
      const data = {
        pkg: require('./package.json'),
        date: new Date()
      }

      const page = () => {
        return src('src/*.html', { base: 'src' })
          .pipe(plugins.swig({ data }))
          .pipe(dest('dist'))
      }
      ```
      > 如果 `src` 的路径需要统配 src 目录下所有html可以写成 `src('src/**/*html')` 。 ** 代表所有目录  

  - 压缩图片
    + 安装依赖模块
    `yarn add gulp-imagemin --dev`

    + 编写核心处理代码
      ```javascript
        const image = () => {
          return src('src/assets/images/**', { base: 'src' })
            .pipe(plugins.imagemin())
            .pipe(dest('dist'))
        }
      ```

  - 打包字体
    + 安装依赖模块  
    同样依赖 `gulp-imagemin` 模块，如果存在svg的字体就会被压缩，如果不存在只会拷贝文件到目标路径。

    + 编写核心处理代码
      ```javascript
        const font = () => {
          return src('src/assets/fonts/**', { base: 'src' })
            .pipe(plugins.imagemin())
            .pipe(dest('dist'))
        }
      ```
  
  - 拷贝其他文件（public目录下）
    + 编写核心处理代码
      ```javascript
        const extra = () => {
          return src('public/**', { base: 'public' })
            .pipe(dest('dist'))
        }pipe(dest('dist'))
        }
      ```
  
  - 删除打包目录（dist目录）
    + 安装依赖模块  
      `yarn add del --dev`
      > `del` 不是 `gulp` 的模块，但是 `del` 操作完成会返回一个 `promise`, 符合 `gulp` 规范, 任务在完成后 `gulp` 可以通过回调标记任务完成。 

    + 编写核心处理代码
      ```javascript
        const del = require('del')

        const clean = () => {
          return del(['dist'])
        }
      ```
  
  - 配置开发服务器
    + 安装依赖模块  
      `yarn add browser-sync --dev`  
    
    + 编写核心处理代码
      ```javascript
        const serve = () => {
          watch('src/assets/styles/*.scss', style)
          watch('src/assets/scripts/*.js', script)
          watch('src/*.html', page)

          watch(
            [
              'src/assets/images/**',
              'src/assets/fonts/**',
              'public/**'
            ], bs.reload
          )

          bs.init(
            {
              server: {
                baseDir: ['dist', 'src', 'public'],
                notify: false,
                files: 'dist/**',
                routes: {
                  '/node_modules': 'node_modules'
                }
              }
            }
          )
        }
      ```
      > - `baseDir` 配置如果为数组，会依次去第一个路径下寻找资源，如果没找到，再去第二个路径找，以此类推。  
      > - `routes` 可配置映射路由地址，如上所示，在 `html` 中引用了 `/node_modules/xx/xx` 路径，运行目录 dist 下并没有这个文件夹，需要将其映射到项目根目录下的 `node_modules` `中。routes` 会优先于 `baseDir` 配置，项目启动后会先去找 `routes` 下的路由配置，如果没有才会去找 `baseDir` 配置 。  
      > - `open` 配置是否启动后自动打开浏览器  
      > - `port` 可指定端口号。  
      > - `notify` 配置是否启动后有通知。  
      > - `files` 监听某路径下文件改变刷新浏览器。  
      > - `serve` 中的 `watch` 方法用来监听文件发生改变执行对应任务。 `image` 、 `font` 、 `public` 三个目录没有对应的 `watch` 方法，而是集中使用了一个`watch` 发生改变后调用 `bs.reload`（重新加载资源文件）,是考虑到开发阶段不需要每次变换都同步一下通篇资源，减少开发阶段的资源消耗，提高开发效率。  

  - 文件引用处理及压缩
    + 安装依赖模块  
      - `yarn add gulp-useref --dev `
      - `yarn add gulp-htmlmin --dev`
      - `yarn add gulp-uglify --dev`
      - `yarn add gulp-clean-css --dev`
      - `yarn add gulp-if --dev`
      > gulp-useref 用来做文件引用并合并文件，把多个 `dist` 目录下不存在的引用文件（例：`node_modules` 下的一些第三方库）读取后打包成一个 `vendor`文件。  
      > `gulp-htmlmin` 压缩 `html` 文件。  
      > `gulp-uglify` 压缩 `js` 文件。  
      > `gulp-clean-css` 压缩 `css` 文件。  
      > `gulp-if` 用来在 `gulp` 工作流中做 `if` 判断。  
    
    + 编写核心处理代码
      ```javascript

      ```

## 参考文献
+ [前端工程化——构建工具选型：grunt、gulp、webpack](https://juejin.im/entry/5b5724d05188251aa01647fd)
